#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) coherent buffer VoxelData {
    uint data[];
};
layout(std430, binding = 1) coherent buffer VoxelVertIdx {
    int idxBuf[];
};
layout(std430, binding = 2) coherent buffer VoxelVerts {
    vec4 verts[];
};
layout(std430, binding = 3) coherent writeonly buffer VoxelElems {
    uint elems[];
};

layout(binding = 4, offset = 0) uniform atomic_uint vertsLength;
layout(binding = 4, offset = 4) uniform atomic_uint nQuads;

uniform uint chunkSize;
uniform float time;
uniform uint smoothIters;

const uint vOrder[6] = {0,2,3,0,3,1};

uint flatIdx(uvec3 c) {
    return c.z * (chunkSize*chunkSize) + c.y * chunkSize + c.x;
}

bool shapeSphere(vec3 p) {
    float r = (float(chunkSize-2) / 2.0);
    return 1.0 - (p.length() / r) > 0.0;
}

bool shapeCube(vec3 p) {
    float r = (sin(time) * 0.5 + 0.5) * (float(chunkSize-2) / 2.0);
    return abs(p.x) < r && abs(p.y) < r && abs(p.z) < r;
}

void genVoxel() {
    const uvec3 c = gl_WorkGroupID;
    const uint C = flatIdx(c);

    data[C] = uint(shapeCube(vec3(c) - vec3(chunkSize/2)));
}

// Generate vertices for surface voxels, returns true if this is a surface voxel
bool genVertices() {
    const uvec3 c = gl_WorkGroupID;

    // Find surface voxels
    uint occupancy = 0;
    vec3 v = vec3(0.0);
    for (uint i = 0; i < 2; i++)
    for (uint j = 0; j < 2; j++)
    for (uint k = 0; k < 2; k++) {
        const uvec3 cc = c + uvec3(i,j,k);
        if (data[flatIdx(cc)] > 0) {
            occupancy += 1;
            v += vec3(cc);
        }
    }
    if (occupancy == 8 || occupancy == 0) {
        return false;
    } else {
        // Add the vertex
        uint idx = atomicCounterIncrement(vertsLength);
        idxBuf[flatIdx(c)] = int(idx);
        verts[idx] = vec4(v / float(occupancy), 1.0);

        return true;
    }
}

// Smooths generated vertices
void smoothSurf() {
    const uvec3 c = gl_WorkGroupID;
    const uint idx = idxBuf[flatIdx(c)];
    vec3 v = verts[idx].xyz;

    for (int r = 0; r < smoothIters; r++) {
        // Relaxation step
        vec3 dv = vec3(0.0);
        float d = 0.0;
        for (int i = -1; i <= 0; i++)
        for (int j = -1; j <= 0; j++)
        for (int k = -1; k <= 0; k++) {
            if (i == -1 && j == -1 && k == -1) continue;
            int vIdx = idxBuf[flatIdx(c + ivec3(i,j,k))];
            if (vIdx >= 0) {
                dv += verts[vIdx].xyz - v;
                d += 1.0;
            }
        }

        memoryBarrierBuffer();

        v += dv * 0.025;
        verts[idx] = vec4(v, 1.0);

        memoryBarrierBuffer();
    }
}

// Generates quads on surface
void genQuads() {
    const uvec3 c = gl_WorkGroupID;

    uint voxHere = data[flatIdx(c)];
    for (int axis = 0; axis < 3; axis++) {
        // If two empty voxels or two filled voxels are sharing a face, there is no surface so no quad
        uvec3 nc = uvec3(0);
        nc[axis] = 1;
        if (data[flatIdx(c+nc)] != voxHere) {
            uint elemOffset = atomicCounterIncrement(nQuads) * 6;
            for (uint i = 0; i < 6; i++) {
                uint j = vOrder[voxHere > 0 ? i : 5-i];
                ivec3 fc = ivec3(0);
                fc[(axis + 1) % 3] -= int(j) / 2;
                fc[(axis + 2) % 3] -= int(j) % 2;
                elems[elemOffset + i] = idxBuf[flatIdx(c + fc)].r;
            }
        }

    }
}

void main() {
    data[flatIdx(gl_WorkGroupID)] = 0;
    memoryBarrier();

    // Generate voxel for this position
    genVoxel();
    if (gl_WorkGroupID.x >= chunkSize-1 ||
        gl_WorkGroupID.y >= chunkSize-1 ||
        gl_WorkGroupID.z >= chunkSize-1) return;
    memoryBarrier();

    // Generate surface vertices
    bool onSurface = genVertices();
    if (!onSurface) return;
    memoryBarrier();

    // Surface smoothing step
    smoothSurf();

    // Generate quads referencing final vertex positions
    if (gl_WorkGroupID.x == 0 ||
        gl_WorkGroupID.y == 0 ||
        gl_WorkGroupID.z == 0) return;
    genQuads();
}