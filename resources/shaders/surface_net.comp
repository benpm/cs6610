#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) coherent buffer VoxelData {
    float voxelData[];
};
layout(std430, binding = 1) coherent buffer VoxelVertIdx {
    int idxBuf[];
};
layout(std430, binding = 2) coherent buffer VoxelVerts {
    vec4 verts[];
};
layout(std430, binding = 3) coherent writeonly buffer VoxelElems {
    uint elems[];
};

layout(binding = 4, offset = 0) uniform atomic_uint vertsLength;
layout(binding = 4, offset = 4) uniform atomic_uint nQuads;

uniform uint chunkSize;
uniform uint smoothIters;

// Order of vertices for quad
const uint vOrder[6] = {0,2,3,0,3,1};

uint flatIdx(uvec3 c) {
    return c.z * (chunkSize*chunkSize) + c.y * chunkSize + c.x;
}

float voxel(uvec3 c) {
    return voxelData[flatIdx(c)];
}

bool voxSolid(uvec3 c) {
    return voxel(c) > 0;
}

// Smooths generated vertices
void smoothSurf() {
    const uvec3 c = gl_GlobalInvocationID;
    const int vIdx = idxBuf[flatIdx(c)];
    if (vIdx < 0) return;

    vec3 v = verts[vIdx].xyz;
    for (int r = 0; r < smoothIters; r++) {
        // Relaxation step
        vec3 dv = vec3(0.0);
        float d = 0.0;
        for (int i = -1; i <= 1; i++)
        for (int j = -1; j <= 1; j++)
        for (int k = -1; k <= 1; k++) {
            int vIdxNbr = idxBuf[flatIdx(c + ivec3(i,j,k))];
            if (vIdxNbr >= 0) {
                dv += verts[vIdxNbr].xyz - v;
                d += 1.0;
            }
        }

        memoryBarrier();

        v += (dv / d) * 1.0;
        verts[vIdx] = vec4(v, 1.0);

        memoryBarrier();
    }
}

// Generates quads on surface
void genQuads() {
    const uvec3 c = gl_GlobalInvocationID;

    bool solidHere = voxSolid(c);
    for (int axis = 0; axis < 3; axis++) {
        // If two empty voxels or two filled voxels are sharing a face, there is no surface so no quad
        uvec3 nc = uvec3(0);
        nc[axis] = 1;
        if (voxSolid(c + nc) != solidHere) {
            bool valid = true;
            int faceIdx[4];
            for (uint i = 0; i < 4; i++) {
                ivec3 fc = ivec3(0);
                fc[(axis + 1) % 3] -= int(i) / 2;
                fc[(axis + 2) % 3] -= int(i) % 2;
                faceIdx[i] = idxBuf[flatIdx(c + fc)];
                if (faceIdx[i] < 0) {
                    valid = false;
                    break;
                }
            }
            if (valid) {
                uint elemOffset = atomicCounterIncrement(nQuads) * 6;
                for (uint i = 0; i < 6; i++) {
                    elems[elemOffset + i] = faceIdx[vOrder[solidHere ? i : 5-i]];
                }
            }
        }

    }
}

void main() {
    const uvec3 c = gl_GlobalInvocationID;

    if (c.x < chunkSize-1 && c.y < chunkSize-1 && c.z < chunkSize-1
        && c.x > 0 && c.y > 0 && c.z > 0)
    {
        if (idxBuf[flatIdx(c)] >= 0) {
            genQuads();
        }
    }
}