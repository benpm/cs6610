#version 460

layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 0) readonly buffer VoxelData {
    uint data[];
};
layout(std430, binding = 1) coherent buffer VoxelVertIdx {
    int idxBuf[];
};
layout(std430, binding = 2) coherent writeonly buffer VoxelVerts {
    vec4 verts[];
};
layout(std430, binding = 3) coherent writeonly buffer VoxelElems {
    uint elems[];
};

layout(binding = 4, offset = 0) uniform atomic_uint vertsLength;
layout(binding = 4, offset = 4) uniform atomic_uint nQuads;

const int _empty = -1;
const int _filled = -2;
const uint chunkSize = 8;
const uint vOrder[6] = {1,3,0,3,2,0};

uint flatIdx(uvec3 c) {
    return c.z * (chunkSize*chunkSize) + c.y * chunkSize + c.x;
}

void main() {
    // Find surface voxels
    uvec3 c = gl_GlobalInvocationID;
    uint occupancy = 0;
    for (uint i = 0; i < 2; i++)
    for (uint j = 0; j < 2; j++)
    for (uint k = 0; k < 2; k++) {
        occupancy += data[flatIdx(c + uvec3(i,j,k))];
    }
    if (occupancy == 8) {
        idxBuf[flatIdx(c)] = _filled;
    } else if (occupancy == 0) {
        idxBuf[flatIdx(c)] = _empty;
    } else {
        vec3 v = vec3(0.0);

        // Linear interpolate the vertex position
        for (uint i = 0; i < 2; i++)
        for (uint j = 0; j < 2; j++)
        for (uint k = 0; k < 2; k++) {
            const uvec3 cc = c + uvec3(i,j,k);
            if (data[flatIdx(cc)] > 0) {
                v += vec3(cc);
            }
        }
        v /= float(occupancy);

        // Add the vertex
        uint idx = atomicCounterIncrement(vertsLength);
        idxBuf[flatIdx(c)] = int(idx);
        verts[idx] = vec4(v, 1.0);
    }

    // Sync invocations operating on idxBuf
    memoryBarrierBuffer();

    // Generate quads
    if (occupancy != 0 && occupancy != 8) {
        for (int dir = -1; dir <= 1; dir += 2) {
            for (int axis = 0; axis < 3; axis++) {
                if (!(dir == 1 && c[axis] == 0) && !(dir == -1 && c[axis] == chunkSize-1)) {
                    int fIdx[4];
                    bool valid = true;
                    for (uint i = 0; i < 4; i++) {
                        // Coordinate of vertex cell on face
                        uvec3 fc = c;
                        fc[(axis + 0) % 3] += i / 2;
                        fc[(axis + 1) % 3] += i % 2;
                        // Previous face coordinate, invalidate face if its filled
                        uvec3 pfc = fc;
                        pfc[(axis + 2) % 3] -= dir;
                        if (idxBuf[flatIdx(pfc)] == _filled) {
                            valid = false;
                            break;
                        }
                        // Check current face
                        int idx = idxBuf[flatIdx(fc)];
                        if (idx < 0) {
                            valid = false;
                            break;
                        } else {
                            fIdx[i] = idx;
                        }
                    }

                    if (valid) {
                        uint elemOffset = atomicCounterIncrement(nQuads) * 6;
                        for (uint i = 0; i < 6; i++) {
                            elems[elemOffset + i] = fIdx[vOrder[dir == 1 ? i : 5 - i]];
                        }
                    }
                }
            }
        }
    }
}