#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) coherent writeonly buffer VoxelVerts {
    vec4 verts[];
};
layout(std430, binding = 1) coherent writeonly buffer VoxelElems {
    uint elems[];
};

uniform layout(binding = 0, r8ui) readonly uimage3D voxData;
uniform layout(binding = 1, r32i) coherent iimage3D idxGrid;

layout(binding = 4) uniform atomic_uint vertsLength;
layout(binding = 4) uniform atomic_uint nQuads;

uniform uint chunkSize;

const int _empty = -420;
const int _filled = -69;
const uint vOrder[6] = {1,3,0,3,2,0};

void main() {
    // Find surface voxels
    ivec3 c = ivec3(gl_WorkGroupID);
    uint occupancy = 0;
    for (uint i = 0; i < 2; i++)
    for (uint j = 0; j < 2; j++)
    for (uint k = 0; k < 2; k++) {
        if (imageLoad(voxData, c + ivec3(i,j,k)).r > 0) {
            occupancy += 1;
        }
    }
    if (occupancy == 8) {
        imageStore(idxGrid, c, ivec4(_filled));
    } else if (occupancy == 0) {
        imageStore(idxGrid, c, ivec4(_empty));
    } else {
        vec3 v = vec3(0.0);

        // Linear interpolate the vertex position
        for (uint i = 0; i < 2; i++)
        for (uint j = 0; j < 2; j++)
        for (uint k = 0; k < 2; k++) {
            const ivec3 cc = c + ivec3(i,j,k);
            if (imageLoad(voxData, cc).r > 0) {
                v += vec3(cc);
            }
        }
        v /= float(occupancy);
        v = vec3(c);

        // Add the vertex
        uint idx = atomicCounterIncrement(vertsLength);
        imageStore(idxGrid, c, ivec4(int(idx)));
        verts[idx] = vec4(v, 1.0);
    }

    // Sync invocations operating on index buffer
    memoryBarrierImage();

    // Generate quads
    for (int dir = -1; dir <= 1; dir += 2) {
        for (int axis = 0; axis < 3; axis++) {
            int fIdx[4];
            bool valid = true;
            for (int i = 0; i < 4; i++) {
                // Coordinate of vertex cell on face
                ivec3 fc = c;
                fc[(axis + 0) % 3] += i / 2;
                fc[(axis + 1) % 3] += i % 2;
                // Previous face coordinate, invalidate face if its filled
                ivec3 pfc = fc;
                pfc[(axis + 2) % 3] -= dir;
                for (int j = 0; j < 3; j++) {
                    if (pfc[j] < 0 || pfc[j] >= int(chunkSize)) {
                        valid = false;
                        break;
                    }
                }
                if (imageLoad(idxGrid, pfc).r == _filled) {
                    valid = false;
                    break;
                }
                // Check current face
                int idx = imageLoad(idxGrid, fc).r;
                if (idx < 0) {
                    valid = false;
                    break;
                } else {
                    fIdx[i] = idx;
                }
            }

            if (valid) {
                uint elemOffset = atomicCounterIncrement(nQuads) * 6;
                for (uint i = 0; i < 6; i++) {
                    elems[elemOffset + i] = fIdx[vOrder[dir == 1 ? i : 5 - i]];
                }
            }
        }
    }
}