#version 460

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout(std430, binding = 0) readonly buffer VoxelData {
    uint data[];
};
layout(std430, binding = 1) coherent buffer VoxelVertIdx {
    int idxBuf[];
};
layout(std430, binding = 2) coherent writeonly buffer VoxelVerts {
    vec4 verts[];
};
layout(std430, binding = 3) coherent writeonly buffer VoxelElems {
    uint elems[];
};

layout(binding = 4, offset = 0) uniform atomic_uint vertsLength;
layout(binding = 4, offset = 4) uniform atomic_uint nQuads;

uniform uint chunkSize;

const int _empty = -1;
const int _filled = -2;
const uint vOrder[6] = {0,2,3,0,3,1};

uint flatIdx(uvec3 c) {
    return c.z * (chunkSize*chunkSize) + c.y * chunkSize + c.x;
}

void main() {
    // Find surface voxels
    uvec3 c = gl_WorkGroupID;
    uint occupancy = 0;
    for (uint i = 0; i < 2; i++)
    for (uint j = 0; j < 2; j++)
    for (uint k = 0; k < 2; k++) {
        occupancy += data[flatIdx(c + uvec3(i,j,k))];
    }
    if (occupancy == 8) {
        idxBuf[flatIdx(c)] = _filled;
    } else if (occupancy == 0) {
        idxBuf[flatIdx(c)] = _empty;
    } else {
        vec3 v = vec3(0.0);

        // Linear interpolate the vertex position
        for (uint i = 0; i < 2; i++)
        for (uint j = 0; j < 2; j++)
        for (uint k = 0; k < 2; k++) {
            const uvec3 cc = c + uvec3(i,j,k);
            if (data[flatIdx(cc)] > 0) {
                v += vec3(cc);
            }
        }
        v /= float(occupancy);

        // Add the vertex
        uint idx = atomicCounterIncrement(vertsLength);
        idxBuf[flatIdx(c)] = int(idx);
        verts[idx] = vec4(v, 1.0);
    }

    // Sync invocations operating on idxBuf
    memoryBarrierBuffer();

    // Generate quads
    if (occupancy != 0 && occupancy != 8) {
        uint v = data[flatIdx(c)];
        // golf me
        for (int axis = 0; axis < 3; axis++) {
            // If two empty voxels or two filled voxels are sharing a face, there is no surface so no quad
            uvec3 nc = uvec3(0);
            nc[axis] = 1;
            if (data[flatIdx(c+nc)] != v) {
                uint elemOffset = atomicCounterIncrement(nQuads) * 6;
                for (uint i = 0; i < 6; i++) {
                    uint j = vOrder[v > 0 ? i : 5-i];
                    ivec3 fc = ivec3(0);
                    fc[(axis + 1) % 3] -= int(j) / 2;
                    fc[(axis + 2) % 3] -= int(j) % 2;
                    elems[elemOffset + i] = idxBuf[flatIdx(c + fc)].r;
                }
            }

        }
    }
}